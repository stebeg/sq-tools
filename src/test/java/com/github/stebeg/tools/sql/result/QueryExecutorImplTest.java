package com.github.stebeg.tools.sql.result;

import com.github.stebeg.tools.sql.query.Select;
import com.github.stebeg.tools.sql.query.Update;
import com.google.common.collect.ImmutableList;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * @author Steffen Berger
 */
@SuppressWarnings({"unchecked"})
public class QueryExecutorImplTest {

    private final ResultSetScanner resultSetScannerMock;
    private final StatementFactory statementFactoryMock;

    private final QueryExecutorImpl instance;

    public QueryExecutorImplTest() {
        this.resultSetScannerMock = mock(ResultSetScanner.class);
        this.statementFactoryMock = mock(StatementFactory.class);

        this.instance = new QueryExecutorImpl(
                this.resultSetScannerMock,
                this.statementFactoryMock);
    }

    @Test
    public void testRunQuery() throws Exception {
        final Connection connectionMock = buildValidConnectionMock();
        final QueryResultItemFactory queryResultItemFactoryMock = mock(QueryResultItemFactory.class);

        final long size = 5, offset = 7;
        final Select select = new Select("SELECT", size, offset);

        final PreparedStatement preparedStatementMock = mock(PreparedStatement.class);
        when(this.statementFactoryMock.createPreparedStatement(connectionMock, select))
                .thenReturn(preparedStatementMock);

        final ResultSet resultSetMock = mock(ResultSet.class);
        when(preparedStatementMock.executeQuery()).thenReturn(resultSetMock);

        final SelectResult expResult = mock(SelectResult.class);
        when(this.resultSetScannerMock
                .scanResultSet(
                        resultSetMock,
                        queryResultItemFactoryMock,
                        size,
                        offset))
                .thenReturn(expResult);

        final SelectResult result = this.instance
                .runQuery(connectionMock, select, queryResultItemFactoryMock);
        assertEquals(expResult, result);

    }

    @Test
    public void testRunUpdate() throws Exception {
        final Update update = new Update("UPDATE", true);
        final Connection connectionMock = buildValidConnectionMock();
        final PreparedStatement preparedStatementMock = mock(PreparedStatement.class);
        when(this.statementFactoryMock.createPreparedStatement(connectionMock, update))
                .thenReturn(preparedStatementMock);

        final int numberOfAffectedRows = 3;
        when(preparedStatementMock.executeUpdate())
                .thenReturn(numberOfAffectedRows);

        final List<Long> generatedKeys = ImmutableList.of(4L, 5L, 9L);
        final ResultSet generatedKeysResultSetMock = mock(ResultSet.class);
        when(generatedKeysResultSetMock.next())
                .thenReturn(
                        Boolean.TRUE,
                        Boolean.TRUE,
                        Boolean.TRUE,
                        Boolean.FALSE);
        when(generatedKeysResultSetMock.getLong(1))
                .thenReturn(
                        generatedKeys.get(0),
                        generatedKeys.get(1),
                        generatedKeys.get(2));
        when(preparedStatementMock.getGeneratedKeys())
                .thenReturn(generatedKeysResultSetMock);

        final UpdateResult expResult = new UpdateResult(numberOfAffectedRows, generatedKeys);
        final UpdateResult result = this.instance.runUpdate(connectionMock, update);

        assertEquals(expResult.getNumberOfAffectedRows(), result.getNumberOfAffectedRows());
        assertEquals(expResult.getAutogeneratedKeys().size(), result.getAutogeneratedKeys().size());
        assertTrue(result.getAutogeneratedKeys().containsAll(expResult.getAutogeneratedKeys()));
    }

    @Test
    public void testRunLargeUpdate() throws Exception {
        final Update update = new Update("UPDATE", false);
        final Connection connectionMock = buildValidConnectionMock();
        final PreparedStatement preparedStatementMock = mock(PreparedStatement.class);
        when(this.statementFactoryMock.createPreparedStatement(connectionMock, update))
                .thenReturn(preparedStatementMock);

        final long numberOfAffectedRows = 123456789L;
        when(preparedStatementMock.executeLargeUpdate())
                .thenReturn(numberOfAffectedRows);

        final UpdateResult expResult = new UpdateResult(numberOfAffectedRows);
        final UpdateResult result = this.instance.runLargeUpdate(connectionMock, update);

        assertEquals(expResult.getNumberOfAffectedRows(), result.getNumberOfAffectedRows());
        assertTrue(result.getAutogeneratedKeys().isEmpty());
    }

    private Connection buildValidConnectionMock() throws SQLException {
        final Connection connectionMock = mock(Connection.class);
        when(connectionMock.isClosed()).thenReturn(Boolean.FALSE);
        when(connectionMock.isValid(1)).thenReturn(Boolean.TRUE);
        return connectionMock;
    }

}
